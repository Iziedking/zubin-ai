{"version":3,"file":"static/js/4262.756643e2.chunk.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/infiniteQueryObserver.ts","../node_modules/@tanstack/react-query/src/useInfiniteQuery.ts","../node_modules/@tanstack/virtual-core/src/utils.ts","../node_modules/@tanstack/virtual-core/src/index.ts","../node_modules/@tanstack/react-virtual/src/index.tsx","../node_modules/use-debounce/src/useDebouncedCallback.ts","../node_modules/use-debounce/src/useDebounce.ts","../node_modules/@tanstack/query-core/src/queriesObserver.ts","../node_modules/@tanstack/react-query/src/useQueries.ts","../node_modules/use-clipboard-copy/dist/index.js"],"sourcesContent":["import type {\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions, ObserverFetchOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  InfiniteData<TData>,\n  InfiniteData<TQueryData>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>,\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions: ObserverFetchOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior(),\n      },\n      notifyOptions,\n    )\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage({ pageParam, ...options }: FetchNextPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward', pageParam },\n      },\n    })\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  }: FetchPreviousPageOptions = {}): Promise<\n    InfiniteQueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward', pageParam },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, InfiniteData<TQueryData>, TQueryKey>,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n\n    const { isFetching, isRefetching } = result\n\n    const isFetchingNextPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'forward'\n\n    const isFetchingPreviousPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'backward'\n\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data?.pages),\n      hasPreviousPage: hasPreviousPage(options, state.data?.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching:\n        isRefetching && !isFetchingNextPage && !isFetchingPreviousPage,\n    }\n  }\n}\n","import 'client-only'\nimport type {\n  QueryObserver,\n  QueryFunction,\n  QueryKey,\n} from '@tanstack/query-core'\nimport { InfiniteQueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => any\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n\n  return (): TResult => {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    opts?.onChange?.(result)\n\n    return result\n  }\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n","import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string\n\nexport interface VirtualItem<TItemElement extends Element> {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n  measureElement: (node: TItemElement | null | undefined) => void\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(element.getBoundingClientRect())\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const entry = entries[0]\n    if (entry?.borderBoxSize) {\n      const box = entry.borderBoxSize[0]\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize })\n        return\n      }\n    }\n    handler(element.getBoundingClientRect())\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (offset: number, isScrolling: boolean) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback = supportsScrollend\n    ? () => undefined\n    : debounce(\n        targetWindow,\n        () => {\n          cb(offset, false)\n        },\n        instance.options.isScrollingResetDelay,\n      )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollLeft' : 'scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: (offset: number, isScrolling: boolean) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback = supportsScrollend\n    ? () => undefined\n    : debounce(\n        targetWindow,\n        () => {\n          cb(offset, false)\n        },\n        instance.options.isScrollingResetDelay,\n      )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n    element.removeEventListener('scrollend', endHandler)\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (offset: number, isScrolling: boolean) => void,\n  ) => void | (() => void)\n\n  // Optional\n  debug?: any\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem<TItemElement>>\n  lanes?: number\n  isScrollingResetDelay?: number\n  enabled?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private scrollToIndexTimeoutId: number | null = null\n  measurementsCache: Array<VirtualItem<TItemElement>> = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem<TItemElement>,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          this._measureElement(entry.target as TItemElement, entry)\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => get()?.disconnect(),\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      ...opts,\n    }\n  }\n\n  private notify = (force: boolean, sync: boolean) => {\n    const { startIndex, endIndex } = this.range ?? {\n      startIndex: undefined,\n      endIndex: undefined,\n    }\n    const range = this.calculateRange()\n\n    if (\n      force ||\n      startIndex !== range?.startIndex ||\n      endIndex !== range?.endIndex\n    ) {\n      this.options.onChange?.(this, sync)\n    }\n  }\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.scrollElement = null\n    this.targetWindow = null\n    this.observer.disconnect()\n    this.elementsCache.clear()\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.notify(false, false)\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.notify(false, false)\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n\n          const prevIsScrolling = this.isScrolling\n          this.isScrolling = isScrolling\n\n          this.notify(prevIsScrolling !== isScrolling, isScrolling)\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem<TItemElement>>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem<TItemElement>>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        return []\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        let measureElement = this.measurementsCache[i]?.measureElement\n\n        if (!measureElement) {\n          measureElement = (node: TItemElement | null | undefined) => {\n            const key = getItemKey(i)\n            const prevNode = this.elementsCache.get(key)\n\n            if (!node) {\n              if (prevNode) {\n                this.observer.unobserve(prevNode)\n                this.elementsCache.delete(key)\n              }\n              return\n            }\n\n            if (prevNode !== node) {\n              if (prevNode) {\n                this.observer.unobserve(prevNode)\n              }\n              this.observer.observe(node)\n              this.elementsCache.set(key, node)\n            }\n\n            if (node.isConnected) {\n              this.resizeItem(\n                i,\n                this.options.measureElement(node, undefined, this),\n              )\n            }\n          }\n        }\n\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end + this.options.gap\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n          measureElement,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n    (measurements, outerSize, scrollOffset) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.calculateRange(),\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return range === null\n        ? []\n        : rangeExtractor({\n            startIndex: range.startIndex,\n            endIndex: range.endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const i = this.indexFromElement(node)\n    const item = this.getMeasurements()[i]\n\n    if (!item || !node.isConnected) {\n      this.elementsCache.forEach((cached, key) => {\n        if (cached === node) {\n          this.observer.unobserve(node)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    const prevNode = this.elementsCache.get(item.key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(item.key, node)\n    }\n\n    this.resizeItem(i, this.options.measureElement(node, entry, this))\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.getMeasurements()[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(true, false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem<TItemElement>> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start'\n      } else if (toOffset >= scrollOffset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      toOffset = toOffset\n    } else if (align === 'end') {\n      toOffset = toOffset - size\n    } else if (align === 'center') {\n      toOffset = toOffset - size / 2\n    }\n\n    const scrollSizeProp = this.options.horizontal\n      ? 'scrollWidth'\n      : 'scrollHeight'\n    const scrollSize = this.scrollElement\n      ? 'document' in this.scrollElement\n        ? this.scrollElement.document.documentElement[scrollSizeProp]\n        : this.scrollElement[scrollSizeProp]\n      : 0\n\n    const maxOffset = scrollSize - size\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.getMeasurements()[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [this.getOffsetForAlignment(toOffset, align), align] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n      this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const offsetAndAlign = this.getOffsetForIndex(index, initialAlign)\n    if (!offsetAndAlign) return\n\n    const [offset, align] = offsetAndAlign\n\n    this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode() && this.targetWindow) {\n      this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.elementsCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const [latestOffset] = notUndefined(\n            this.getOffsetForIndex(index, align),\n          )\n\n          if (!approxEqual(latestOffset, this.getScrollOffset())) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else {\n      // If lanes is 1, use the last measurement's end, otherwise find the maximum end value among all measurements\n      end =\n        this.options.lanes === 1\n          ? measurements[measurements.length - 1]?.end ?? 0\n          : Math.max(\n              ...measurements.slice(-this.options.lanes).map((m) => m.end),\n            )\n    }\n\n    return end - this.options.scrollMargin + this.options.paddingEnd\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.options.onChange?.(this, false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange<TItemElement extends Element>({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: Array<VirtualItem<TItemElement>>\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n","import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  Virtualizer,\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll,\n} from '@tanstack/virtual-core'\nimport type { PartialKeys, VirtualizerOptions } from '@tanstack/virtual-core'\n\nexport * from '@tanstack/virtual-core'\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance, sync) => {\n      if (sync) {\n        flushSync(rerender)\n      } else {\n        rerender()\n      }\n      options.onChange?.(instance, sync)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => (typeof document !== 'undefined' ? window.scrollY : 0),\n    ...options,\n  })\n}\n","import { useRef, useEffect, useMemo } from 'react';\n\nexport interface CallOptions {\n  /**\n   * Controls if the function should be invoked on the leading edge of the timeout.\n   */\n  leading?: boolean;\n  /**\n   * Controls if the function should be invoked on the trailing edge of the timeout.\n   */\n  trailing?: boolean;\n}\n\nexport interface Options extends CallOptions {\n  /**\n   * The maximum time the given function is allowed to be delayed before it's invoked.\n   */\n  maxWait?: number;\n  /**\n   * If the setting is set to true, all debouncing and timers will happen on the server side as well\n   */\n  debounceOnServer?: boolean;\n}\n\nexport interface ControlFunctions<ReturnT> {\n  /**\n   * Cancel pending function invocations\n   */\n  cancel: () => void;\n  /**\n   * Immediately invoke pending function invocations\n   */\n  flush: () => ReturnT | undefined;\n  /**\n   * Returns `true` if there are any pending function invocations\n   */\n  isPending: () => boolean;\n}\n\n/**\n * Subsequent calls to the debounced function return the result of the last func invocation.\n * Note, that if there are no previous invocations you will get undefined. You should check it in your code properly.\n */\nexport interface DebouncedState<T extends (...args: any) => ReturnType<T>>\n  extends ControlFunctions<ReturnType<T>> {\n  (...args: Parameters<T>): ReturnType<T> | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn.\n *\n * The debounced function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the debounced function.\n *\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n *  Controls if `func` should be invoked on the leading edge of the timeout.\n * @param {boolean} [options.leading=false]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {number} [options.maxWait]\n *  Controls if `func` should be invoked the trailing edge of the timeout.\n * @param {boolean} [options.trailing=true]\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * const resizeHandler = useDebouncedCallback(calculateLayout, 150);\n * window.addEventListener('resize', resizeHandler)\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * const clickHandler = useDebouncedCallback(sendMail, 300, {\n *   leading: true,\n *   trailing: false,\n * })\n * <button onClick={clickHandler}>click me</button>\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * source.addEventListener('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * window.addEventListener('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nexport default function useDebouncedCallback<\n  T extends (...args: any) => ReturnType<T>,\n>(func: T, wait?: number, options?: Options): DebouncedState<T> {\n  const lastCallTime = useRef(null);\n  const lastInvokeTime = useRef(0);\n  const timerId = useRef(null);\n  const lastArgs = useRef<unknown[]>([]);\n  const lastThis = useRef<unknown>();\n  const result = useRef<ReturnType<T>>();\n  const funcRef = useRef(func);\n  const mounted = useRef(true);\n  // Always keep the latest version of debounce callback, with no wait time.\n  funcRef.current = func;\n\n  const isClientSide = typeof window !== 'undefined';\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !wait && wait !== 0 && isClientSide;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n  options = options || {};\n\n  const leading = !!options.leading;\n  const trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default\n  const maxing = 'maxWait' in options;\n  const debounceOnServer =\n    'debounceOnServer' in options ? !!options.debounceOnServer : false; // `false` by default\n  const maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;\n\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  // You may have a question, why we have so many code under the useMemo definition.\n  //\n  // This was made as we want to escape from useCallback hell and\n  // not to initialize a number of functions each time useDebouncedCallback is called.\n  //\n  // It means that we have less garbage for our GC calls which improves performance.\n  // Also, it makes this library smaller.\n  //\n  // And the last reason, that the code without lots of useCallback with deps is easier to read.\n  // You have only one place for that.\n  const debounced = useMemo(() => {\n    const invokeFunc = (time: number) => {\n      const args = lastArgs.current;\n      const thisArg = lastThis.current;\n\n      lastArgs.current = lastThis.current = null;\n      lastInvokeTime.current = time;\n      return (result.current = funcRef.current.apply(thisArg, args));\n    };\n\n    const startTimer = (pendingFunc: () => void, wait: number) => {\n      if (useRAF) cancelAnimationFrame(timerId.current);\n      timerId.current = useRAF\n        ? requestAnimationFrame(pendingFunc)\n        : setTimeout(pendingFunc, wait);\n    };\n\n    const shouldInvoke = (time: number) => {\n      if (!mounted.current) return false;\n\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (\n        !lastCallTime.current ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    };\n\n    const trailingEdge = (time: number) => {\n      timerId.current = null;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs.current) {\n        return invokeFunc(time);\n      }\n      lastArgs.current = lastThis.current = null;\n      return result.current;\n    };\n\n    const timerExpired = () => {\n      const time = Date.now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // https://github.com/xnimorz/use-debounce/issues/97\n      if (!mounted.current) {\n        return;\n      }\n      // Remaining wait calculation\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n      const timeWaiting = wait - timeSinceLastCall;\n      const remainingWait = maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n\n      // Restart the timer\n      startTimer(timerExpired, remainingWait);\n    };\n\n    const func: DebouncedState<T> = (...args: Parameters<T>): ReturnType<T> => {\n      if (!isClientSide && !debounceOnServer) {\n        return;\n      }\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n\n      lastArgs.current = args;\n      lastThis.current = this;\n      lastCallTime.current = time;\n\n      if (isInvoking) {\n        if (!timerId.current && mounted.current) {\n          // Reset any `maxWait` timer.\n          lastInvokeTime.current = lastCallTime.current;\n          // Start the timer for the trailing edge.\n          startTimer(timerExpired, wait);\n          // Invoke the leading edge.\n          return leading ? invokeFunc(lastCallTime.current) : result.current;\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime.current);\n        }\n      }\n      if (!timerId.current) {\n        startTimer(timerExpired, wait);\n      }\n      return result.current;\n    };\n\n    func.cancel = () => {\n      if (timerId.current) {\n        useRAF\n          ? cancelAnimationFrame(timerId.current)\n          : clearTimeout(timerId.current);\n      }\n      lastInvokeTime.current = 0;\n      lastArgs.current =\n        lastCallTime.current =\n        lastThis.current =\n        timerId.current =\n          null;\n    };\n\n    func.isPending = () => {\n      return !!timerId.current;\n    };\n\n    func.flush = () => {\n      return !timerId.current ? result.current : trailingEdge(Date.now());\n    };\n\n    return func;\n  }, [\n    leading,\n    maxing,\n    wait,\n    maxWait,\n    trailing,\n    useRAF,\n    isClientSide,\n    debounceOnServer,\n  ]);\n\n  return debounced;\n}\n","import { useCallback, useRef, useState } from 'react';\nimport useDebouncedCallback, { DebouncedState } from './useDebouncedCallback';\n\nfunction valueEquality<T>(left: T, right: T): boolean {\n  return left === right;\n}\n\nexport default function useDebounce<T>(\n  value: T,\n  delay: number,\n  options?: {\n    maxWait?: number;\n    leading?: boolean;\n    trailing?: boolean;\n    equalityFn?: (left: T, right: T) => boolean;\n  }\n): [T, DebouncedState<(value: T) => void>] {\n  const eq = (options && options.equalityFn) || valueEquality;\n\n  const activeValue = useRef(value);\n  const [, forceUpdate] = useState({});\n  const debounced = useDebouncedCallback(\n    useCallback(\n      (value: T) => {\n        activeValue.current = value;\n        forceUpdate({});\n      },\n      [forceUpdate]\n    ),\n    delay,\n    options\n  );\n  const previousValue = useRef(value);\n\n  if (!eq(previousValue.current, value)) {\n    debounced(value);\n    previousValue.current = value;\n  }\n\n  return [activeValue.current as T, debounced];\n}\n","import { difference, replaceAt } from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  QueryObserverOptions,\n  QueryObserverResult,\n  DefaultedQueryObserverOptions,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\n\ntype QueriesObserverListener = (result: QueryObserverResult[]) => void\n\nexport class QueriesObserver extends Subscribable<QueriesObserverListener> {\n  private client: QueryClient\n  private result: QueryObserverResult[]\n  private queries: QueryObserverOptions[]\n  private observers: QueryObserver[]\n  private observersMap: Record<string, QueryObserver>\n\n  constructor(client: QueryClient, queries?: QueryObserverOptions[]) {\n    super()\n\n    this.client = client\n    this.queries = []\n    this.result = []\n    this.observers = []\n    this.observersMap = {}\n\n    if (queries) {\n      this.setQueries(queries)\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: QueryObserverOptions[],\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.queries = queries\n\n    notifyManager.batch(() => {\n      const prevObservers = this.observers\n\n      const newObserverMatches = this.findMatchingObservers(this.queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newObserversMap = Object.fromEntries(\n        newObservers.map((observer) => [observer.options.queryHash, observer]),\n      )\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.observers = newObservers\n      this.observersMap = newObserversMap\n      this.result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.onUpdate(observer, result)\n        })\n      })\n\n      this.notify()\n    })\n  }\n\n  getCurrentResult(): QueryObserverResult[] {\n    return this.result\n  }\n\n  getQueries() {\n    return this.observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.observers\n  }\n\n  getOptimisticResult(queries: QueryObserverOptions[]): QueryObserverResult[] {\n    return this.findMatchingObservers(queries).map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n  }\n\n  private findMatchingObservers(\n    queries: QueryObserverOptions[],\n  ): QueryObserverMatch[] {\n    const prevObservers = this.observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: QueryObserverMatch[] =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const matchingObserversSet = new Set(\n      matchingObservers.map((match) => match.observer),\n    )\n    const unmatchedObservers = prevObservers.filter(\n      (prevObserver) => !matchingObserversSet.has(prevObserver),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.client.defaultQueryOptions(options)\n      const currentObserver = this.observersMap[defaultedOptions.queryHash!]\n      return currentObserver ?? new QueryObserver(this.client, defaultedOptions)\n    }\n\n    const newOrReusedObservers: QueryObserverMatch[] = unmatchedQueries.map(\n      (options, index) => {\n        if (options.keepPreviousData) {\n          // return previous data from one of the observers that no longer match\n          const previouslyUsedObserver = unmatchedObservers[index]\n          if (previouslyUsedObserver !== undefined) {\n            return {\n              defaultedQueryOptions: options,\n              observer: previouslyUsedObserver,\n            }\n          }\n        }\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      },\n    )\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  private onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result)\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({ listener }) => {\n        listener(this.result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n","import 'client-only'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryFunction } from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  shouldSuspend,\n  fetchOptimistic,\n  willFetch,\n} from './suspense'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useClipboard = void 0;\nvar clipboard_copy_1 = __importDefault(require(\"clipboard-copy\"));\nvar react_1 = require(\"react\");\nvar useTimedToggle_1 = require(\"./useTimedToggle\");\nfunction isInputLike(node) {\n    return node && (node.nodeName === 'TEXTAREA' || node.nodeName === 'INPUT');\n}\nfunction useClipboard(options) {\n    if (options === void 0) { options = {}; }\n    var _a = useTimedToggle_1.useTimedToggle(false), copied = _a[0], toggleCopied = _a[1];\n    var targetRef = react_1.useRef(null);\n    var optionsRef = react_1.useRef(options);\n    optionsRef.current = options;\n    function isSupported() {\n        return (!!navigator.clipboard ||\n            (typeof document.execCommand === 'function' &&\n                typeof document.queryCommandSupported === 'function' &&\n                document.queryCommandSupported('copy')));\n    }\n    var copyHandler = react_1.useCallback(function (text) {\n        var opts = optionsRef.current;\n        var target = targetRef.current;\n        function handleSuccess() {\n            if (opts.onSuccess) {\n                opts.onSuccess();\n            }\n            if (opts.copiedTimeout) {\n                toggleCopied(opts.copiedTimeout);\n            }\n            if (opts.selectOnCopy && isInputLike(target)) {\n                target.select();\n            }\n        }\n        function handleError() {\n            if (opts.onError) {\n                opts.onError();\n            }\n            if (opts.selectOnError !== false && isInputLike(target)) {\n                target.select();\n            }\n        }\n        function copy(value) {\n            clipboard_copy_1.default(value).then(handleSuccess).catch(handleError);\n        }\n        if (typeof text === 'string') {\n            copy(text);\n        }\n        else if (target) {\n            copy(target.value);\n        }\n    }, []);\n    return {\n        copied: copied,\n        copy: copyHandler,\n        isSupported: isSupported,\n        target: targetRef,\n    };\n}\nexports.useClipboard = useClipboard;\n"],"names":["InfiniteQueryObserver","QueryObserver","constructor","client","options","super","bindMethods","this","fetchNextPage","bind","fetchPreviousPage","setOptions","notifyOptions","behavior","infiniteQueryBehavior","getOptimisticResult","pageParam","fetch","meta","fetchMore","direction","createResult","query","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","state","result","isFetching","isRefetching","isFetchingNextPage","fetchMeta","isFetchingPreviousPage","hasNextPage","data","pages","hasPreviousPage","useInfiniteQuery","arg1","arg2","arg3","parseQueryArgs","useBaseQuery","memo","getDeps","fn","opts","deps","initialDeps","_a","_b","_c","_d","depTime","key","debug","call","Date","now","newDeps","length","some","dep","index","resultTime","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","onChange","notUndefined","value","msg","Error","debounce","targetWindow","ms","timeoutId","args","clearTimeout","setTimeout","apply","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","i","push","observeElementRect","instance","cb","element","scrollElement","handler","rect","width","height","getBoundingClientRect","ResizeObserver","observer","entries","entry","borderBoxSize","box","inlineSize","blockSize","observe","unobserve","addEventListenerOptions","passive","supportsScrollend","window","observeElementOffset","offset","fallback","isScrollingResetDelay","createHandler","isScrolling","horizontal","endHandler","addEventListener","removeEventListener","measureElement","elementScroll","adjustments","toOffset","scrollTo","Virtualizer","unsubs","scrollToIndexTimeoutId","measurementsCache","itemSizeCache","Map","pendingMeasuredCacheIndexes","scrollRect","scrollOffset","scrollDirection","scrollAdjustments","elementsCache","_ro","get","forEach","_measureElement","target","disconnect","opts2","Object","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","initialRect","scrollMargin","gap","indexAttribute","initialMeasurementsCache","lanes","enabled","notify","force","sync","calculateRange","cleanup","filter","Boolean","d","clear","_didMount","_willUpdate","getScrollElement","ownerDocument","defaultView","_scrollToOffset","getScrollOffset","prevIsScrolling","getSize","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","has","lane","previousFurthestMeasurement","set","size","Array","from","values","sort","a","b","getMeasurementOptions","getMeasurements","item","slice","measureElement2","node","key2","prevNode","isConnected","resizeItem","delete","furthestMeasurement","measuredSize","estimateSize","process","outerSize","getOffset","findNearestBinarySearch","getIndexes","indexFromElement","attributeName","indexStr","getAttribute","parseInt","warn","cached","delta","shouldAdjustScrollPositionOnItemSizeChange","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","getOffsetForAlignment","align","scrollSizeProp","maxOffset","document","documentElement","getOffsetForIndex","isDynamicMode","cancelScrollToIndex","scrollToOffset","scrollToIndex","initialAlign","offsetAndAlign","latestOffset","abs","approxEqual","scrollBy","getTotalSize","map","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","useIsomorphicLayoutEffect","React","useVirtualizerBase","rerender","resolvedOptions","instance2","flushSync","useVirtualizer","c","e","u","r","o","f","l","v","g","current","p","w","TypeError","s","leading","x","trailing","h","y","debounceOnServer","F","maxWait","n","A","t","cancelAnimationFrame","requestAnimationFrame","arguments","cancel","isPending","flush","equalityFn","QueriesObserver","Subscribable","queries","observers","observersMap","setQueries","onSubscribe","listeners","subscribe","onUpdate","onUnsubscribe","destroy","Set","notifyManager","batch","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","newObserversMap","fromEntries","queryHash","newResult","getCurrentResult","hasIndexChange","hasListeners","difference","getQueries","getCurrentQuery","getObservers","prevObserversMap","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","keepPreviousData","previouslyUsedObserver","undefined","concat","sortMatchesByOrderOfQueries","indexOf","replaceAt","listener","useQueries","context","queryClient","useQueryClient","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedQueries","_optimisticResults","ensureStaleTime","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","optimisticResult","useSyncExternalStore","onStoreChange","batchCalls","suspensePromises","shouldSuspend","queryObserver","fetchOptimistic","willFetch","Promise","all","observerQueries","firstSingleResultWhichShouldThrow","find","_defaultedQueries$ind","_defaultedQueries$ind2","getHasError","useErrorBoundary","error","__importDefault","mod","__esModule","defineProperty","exports","useClipboard","clipboard_copy_1","require","react_1","useTimedToggle_1","isInputLike","nodeName","useTimedToggle","copied","toggleCopied","targetRef","useRef","optionsRef","copy","useCallback","text","handleSuccess","onSuccess","copiedTimeout","selectOnCopy","select","handleError","onError","selectOnError","default","then","catch","isSupported","navigator","clipboard","execCommand","queryCommandSupported"],"sourceRoot":""}